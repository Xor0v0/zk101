import { Callout } from "nextra/components";
import Image from 'next/image'
import { MultiPolynomialPlot } from "@/components/MultiPoly";
import { SinglePoly } from "@/components/Poly";

## 多项式是什么？

多项式其实和非常在写法上和方程非常相似
- 多项式： $f(x) = x^2 + 2x + 1$
- 方程： $x^2 + 2x + 1 = 0$
  
他们之间微弱的差别在于，多项式是一个函数，而方程是一个等式。  

说白了：
- **多项式是一个函数**，他的目的是求这个函数运算后的值。不包含等号
- **方程是一个等式**，他的目的是找到满足这个等式的解。包含等号

## 多项式的一些术语

- **根（Root）**：多项式的根是让多项式等于0的那些x值。
- **系数（Coefficient）**：多项式中每个项的数字因子。比如 $x^2 + 8x + 1$ 中，8就是x的系数。
- **次数（Degree）**：多项式中最高次项的次数。比如 $x^2 + 8x + 1$ 中，次数就是2。
- **多项式插值**：通过已知的多项式在某几个点的值，来推断多项式。
- **评估（Evaluation）**：将一个值代入多项式，计算出多项式的值。

## 多项式的根

多项式的根（也叫零点）是让多项式等于0的那些x值。比如：

对于多项式 $f(x) = x^2 - 1$，它的根是 1 和 -1，因为：
- $f(1) = 1^2 - 1 = 0$
- $f(-1) = (-1)^2 - 1 = 0$

<Callout emoji="💡">
在ZK证明中，多项式的根具有特殊意义：
- 它们可以用来编码我们想要证明的信息
- 通过检查多项式在某点是否为0，我们可以验证某个条件是否成立
</Callout>

## 多项式的构建 - 拉格朗日插值法  
在ZK中，我们经常需要寻找一个点集的多项式，这个多项式可以在所有的点上经过。

一般来说，我们会使用拉格朗日插值法来构建多项式。这是一种非常简单的方法。
构建过程分为两步：

1. **构造基底多项式**
对每个点 $(x_i,y_i)$，构造一个多项式 $l_i(x)$，使得：
- 在 $x_i$ 处值为1
- 在其他点处值为0

```math
l_i(x) = \prod_{j \neq i} \frac{x - x_j}{x_i - x_j}
```

2. **组合最终多项式**
将每个基底多项式乘以对应的y值，然后相加：

```math
f(x) = \sum_{i} y_i \cdot l_i(x)
```

**如果你没看懂，或者不想看上面的公式**，没关系，我们通过一些简单的例子来学习。

<div className="flex gap-4 mt-4">
<div className="pr-2 border-r-2">
<div>
假设点集为：
</div>
|x|y|
|---|---|
|1|2|
|2|3|
|3|8|
|4|4|
</div>
<div className="pr-2 border-r-2">
1. 构造基底多项式：
```math
\begin{align*}
l_1(x) &= \frac{(x-2)(x-3)(x-4)}{(1-2)(1-3)(1-4)}  \\
l_2(x) &= \frac{(x-1)(x-3)(x-4)}{(2-1)(2-3)(2-4)}  \\
l_3(x) &= \frac{(x-1)(x-2)(x-4)}{(3-1)(3-2)(3-4)}  \\
l_4(x) &= \frac{(x-1)(x-2)(x-3)}{(4-1)(4-2)(4-3)}
\end{align*}
```

2. 组合最终多项式：
```math
f(x) = 2l_1(x) + 3l_2(x) + 8l_3(x) + 4l_4(x)
```
</div>
<div>
我们仔细端详一下这几个基底多项式，我们可以很容易的发现，**他们的目的都是在于构建一个在$x_i$处值为1，在其他点处值为0的多项式**。  
可以看看下面的示例图，尝试看一下每个点的值。（你可以点击标签🏷️名称来隐藏当前多项式曲线）
</div>
</div>

<MultiPolynomialPlot polys={["(x-2)(x-3)(x-4)/(1-2)(1-3)(1-4)","(x-1)(x-3)(x-4)/(2-1)(2-3)(2-4)","(x-1)(x-2)(x-4)/(3-1)(3-2)(3-4)","(x-1)(x-2)(x-3)/(4-1)(4-2)(4-3)"]} makers={[1,2,3,4]} />

很明显，上面的多项式在$x_i$处值为1，在其他点处值为0。此时，我们获得了多个基底多项式。

那么如何获得一个能通过所有点的多项式呢？

我们只需要将每个基底多项式乘以对应的y值，然后相加（只看结果就行）：

```math
\begin{align*}
f(x) &= 2l_1(x) + 3l_2(x) + 8l_3(x) + 4l_4(x) \\
&= 2 \cdot \frac{(x-2)(x-3)(x-4)}{(1-2)(1-3)(1-4)} + 3 \cdot \frac{(x-1)(x-3)(x-4)}{(2-1)(2-3)(2-4)} + 8 \cdot \frac{(x-1)(x-2)(x-4)}{(3-1)(3-2)(3-4)} + 4 \cdot \frac{(x-1)(x-2)(x-3)}{(4-1)(4-2)(4-3)} \\
&= \frac{13}{6}x^3 + 15x^2 - \frac{173}{6}x + 18
\end{align*}
```

<SinglePoly title="最终多项式" poly="-13/6*x^3+15*x^2-173/6*x+18" x={Array.from({length: 41}, (_, i) => i/10)} data={{name: "最终多项式"}} markers={[1,2,3,4]} />

是不是很简单？总结一下来说就是两个步骤：
1. 构建多个基础多项式，这个多项式就是**让$x_i$ 处值为1，其他点为0**
2. 将所有的多项式相加起来，只要每个多项式在都遵守上面的条件，那么就可以通过每一个点。