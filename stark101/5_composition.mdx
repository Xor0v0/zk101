---
title: 5. 组合多项式（Composition Polynomial）
---
import Center from "@/components/Float";
import { Callout } from "nextra/components";

## 导读
组合多项式（Composition Polynomial）是Stark中用于将多个约束多项式组合在一起，从而形成一个最终的多项式。

但是在章节开始之前，你需要**必须 🚨**掌握以下前置知识：

- [Stark 101 - 4. Constraints](./4_constraints.mdx)

以上内容均为超级精简版，强烈推荐看一遍。

## 组合多项式
现在到了我们对约束多项式进行组合的时候了。

### 为什么？
我们现在其实拿到了3个约束多项式，但是在不同场景下，约束的多项式数量可能更多，所以，我们可以把多项式进行组合，从而形成一个最终的多项式。

这样可以带来几个好处：
- **效率提升**：减少多项式的数量，从而减少计算量
- **单一承诺**：减少承诺的数量，从而减少证明的大小

### 组合方式
多项式的组合其实就是加起来，但是，我们需要生成不同的随机数，从而避免多项式之间的相互影响。比如，避免攻击者构造特殊多项式让他们相互抵消从而构建错误但是有效的证明。

<Callout emoji="💡" type="info">
还记得我们之前承诺的值吗？我们根据之前Hash链的结果生成一个确定性的随机数，并且生成后将这个随机数继续作为承诺值提交，这里的技术细节我们不展开，只需要知道有一个确定性的随机数生成器，但是这个确定性在生成之前没有办法知道。
</Callout>

于是我们这里获得3个随机数，分别是$r_0$, $r_1$, $r_2$，然后我们根据随机数和约束多项式，生成最终的多项式(此处为简单的数学计算)。
$$
CP(x) = r_0 \cdot p_0(x) + r_1 \cdot p_1(x) + r_2 \cdot p_2(x)
$$

## 提交组合多项式的所有值承诺

接下来就是和之前Trace一样，我们在扩域后的乘法子群上计算组合多项式的所有值。

计算：
$$
\forall i \in F_{LDE}, CP(g^i) = r_0 \cdot p_0(g^i) + r_1 \cdot p_1(g^i) + r_2 \cdot p_2(g^i)
$$

**然后构建默克尔树并提交Hash作为承诺值**。

## 小结

组合多项式是Stark中非常重要的一步，通过组合多项式，我们可以将多个约束多项式组合在一起，从而形成一个最终的多项式，这样可以带来效率提升和单一承诺的好处。