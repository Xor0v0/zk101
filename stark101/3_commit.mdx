---
title: 3. 承诺（Commitments）
---
import { Callout } from "nextra/components";
import { HHH, GuoYu } from "@/lib/people";
import { SinglePoly } from "@/components/Poly";
import Image from "next/image";

## 导读
承诺（Commitments）是Stark中用于去除需要交互验证的步骤，通过将Trace的值进行默克尔树构建，从而获得虚拟的交互验证。

但是在章节开始之前，你需要**必须 🚨**掌握以下前置知识：

- [Stark 101 - 2. LDE](./2_lde.mdx)
- [知识库 - 乘法群](../knowledges/1_multiplicative_group.mdx)
- [知识库 - 多项式](../knowledges/2_polynomial.mdx)
- [知识库 - 默克尔树](../knowledges/3_merkle_tree.mdx)

以上内容均为超级精简版，强烈推荐看一遍。

## 承诺之前
在前两张，我们分别学习了Trace和LDE，我们这里复习一下他们的作用：

- Trace 是计算过程中所有的中间值，以及最终的执行结果。
- LDE 是用于将Trace的值拓展到更大的域，从而提高计算的安全性。

那么，很奇怪的是，我们获得的Trace值，X轴上的点有些是连续的，根本没法通过LDE来拓展！

这里我们就需要知道另外一个事情，Stark中，我们会把Trace的值按照顺序平铺，然后将所有的值映射到一个满足大小的乘法子群中。

<Callout emoji="📖" type="info">
为什么不能用自然数类似（0,1,2,3,4,5,6,7,8,9,10），而是需要用乘法子群？
根据<HHH />和<GuoYu />的解释，大致上来说主要是两个原因：

1. FRI协议需要使用FFT（快速傅里叶变换）来高效地在大量点上评估多项式：
   - FFT需要在"单位根"上工作
   - 乘法子群的循环特性恰好提供了这些单位根
   - 这让验证过程变得非常高效，从O(n²)降到O(n log n)

2. 域的性质保证了所有必要的运算都能精确进行：
   - 每个非零元素都有乘法逆元
   - 所有的除法运算都能得到精确结果
   - 不会出现"除不尽"的情况

其中第一点是选择乘法子群的主要原因。

也就是说，确实可以选择一个任意的有限域，但是性能上并不好。
</Callout>

前两个章节，我们都在自然数上进行运算，但是**Stark中，实际上LDE的过程会在乘法子群中进行**。

因此，我们现在需要把我们Trace的值，映射到乘法子群中。

根据[乘法群](../knowledges/1_multiplicative_group.mdx)中的知识，我们知道，乘法子群的生成方式来源于对原群按照固定间隔进行取值的过程。  
在Stark中，不同的实现方案会使用不同的域，也就是不同大小的乘法群。

为了方便，我们**使用$F_{127}$作为接下来计算的域**。他的生成元是**3**。（一般Stark中，不会使用这么小的域）

### 生成子群
首先，我们Trace的值只有 `0,1,1,2,3,5,8,13,21,34,55,89,144,233`,总共为14个值。。
还记得[乘法群](../knowledges/1_multiplicative_group.mdx)中的知识吗？我们需要选择一个子群的大小，这个大小需要是126的约数。而14刚好是一个126的约数。

因此，计算一下126/14=9。生成元就是$3^9$。

结果如下表：

| 原序列 | 0 | 1 | 1 | 2 | 3 | 5 | 8 | 13 | 21 | 34 | 55 | 89 | 144 | 233 |  |
|-----|---|---|---|---|---|---|---|---|---|---|----|----|----|----|----|
| 计算式 $3^{9^n} mod\ 127$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
|结果 | 1|125|4|119|16|95|64|126|2|123|8|111|32|63|1

### 构建多项式
根据[多项式](../knowledges/2_polynomial.mdx)中的知识，我们使用拉格朗日插值法，构建多项式。
结果如下（高能预警）：
```math
\begin{align*}
f(x) = & \frac{978650033535651358649927 x^{13}}{899302089236438485351638244645776691200000} -  
        \frac{809006461041262874197656301 x^{12}}{899302089236438485351638244645776691200000} + \\ 
        & \frac{296713635083782768265456456803 x^{11}}{899302089236438485351638244645776691200000} - 
        \frac{63605773551069742870318074718589 x^{10}}{899302089236438485351638244645776691200000} + \\ 
        & \frac{2943377467562483898104055733453207 x^{9}}{299767363078812828450546081548592230400000} - 
        \frac{211359181413299286771104144793029 x^{8}}{229004861022775270015696013406105600000} + \\ 
        & \frac{136949318294046172910077860179402839 x^{7}}{2300005343315699451027207786817843200000} - 
        \frac{138100508017536336433876784112757680511 x^{6}}{52900122896261087373625779096810393600000} + \\ 
        & \frac{8259993059048206817256045414950042791 x^{5}}{109778087064994932293901152910861412500} -  
        \frac{225370748239166358154860869633396297911 x^{4}}{167905543173345497638468678985395200000} + \\ 
        & \frac{84482478374499854179900209882137400652067 x^{3}}{6245153397475267259386376698929004800000} - 
        \frac{53209374585065904235443917367730473162337 x^{2}}{780644174684408407423297087366125600000} + \\ 
        & \frac{195249095907746049143398278868958557 x}{1312624722027859173095401344105000}  - 
        \frac{17917445582623980664271504}{192983681150126956214455}
\end{align*}
```

这个其实没必要过多关注，我们一般不会手动计算，而是使用代码来生成。

他的图像差不多是这样（你可以点击下方标签来隐藏多项式，只看点）：

# 修改为点图，非曲线图
<SinglePoly title="最终多项式" poly="(978650033535651358649927 x^13)/899302089236438485351638244645776691200000 - (809006461041262874197656301 x^12)/899302089236438485351638244645776691200000 + (296713635083782768265456456803 x^11)/899302089236438485351638244645776691200000 - (63605773551069742870318074718589 x^10)/899302089236438485351638244645776691200000 + (2943377467562483898104055733453207 x^9)/299767363078812828450546081548592230400000 - (211359181413299286771104144793029 x^8)/229004861022775270015696013406105600000 + (136949318294046172910077860179402839 x^7)/2300005343315699451027207786817843200000 - (138100508017536336433876784112757680511 x^6)/52900122896261087373625779096810393600000 + (8259993059048206817256045414950042791 x^5)/109778087064994932293901152910861412500 - (225370748239166358154860869633396297911 x^4)/167905543173345497638468678985395200000 + (84482478374499854179900209882137400652067 x^3)/6245153397475267259386376698929004800000 - (53209374585065904235443917367730473162337 x^2)/780644174684408407423297087366125600000 + (195249095907746049143398278868958557 x)/1312624722027859173095401344105000 - 17917445582623980664271504/192983681150126956214455" x={Array.from({length: 127}, (_, i) => i)} data={{name: "多项式在每一个点上的值",mode:"markers",marker:{size:4}}} markers={[1, 125, 4, 119, 16, 95, 64, 126, 2, 123, 8, 111, 32, 63]} />

### LDE
来进行我们的LDE的计算吧！按照之前学的内容，我们可以轻松的构建出新的乘法子群，这里按照扩大到42个元素来计算。
根据公式轻松计算 126/42=3。生成元就是$3^3$。从而得到新的乘法子群。

<Callout emoji="💡" type="info">
新的乘法子群为：[1, 27, 94, 125, 73, 66, 4, 108, 122, 119, 38, 10, 16, 51, 107, 95, 25, 40, 64, 77, 47, 126, 100, 33, 2, 54, 61, 123, 19, 5, 8, 89, 117, 111, 76, 20, 32, 102, 87, 63, 50, 80]

感兴趣可以根据上面给出的生成方式验算一下。
</Callout>

<SinglePoly title="扩域后多项式" poly="(978650033535651358649927 x^13)/899302089236438485351638244645776691200000 - (809006461041262874197656301 x^12)/899302089236438485351638244645776691200000 + (296713635083782768265456456803 x^11)/899302089236438485351638244645776691200000 - (63605773551069742870318074718589 x^10)/899302089236438485351638244645776691200000 + (2943377467562483898104055733453207 x^9)/299767363078812828450546081548592230400000 - (211359181413299286771104144793029 x^8)/229004861022775270015696013406105600000 + (136949318294046172910077860179402839 x^7)/2300005343315699451027207786817843200000 - (138100508017536336433876784112757680511 x^6)/52900122896261087373625779096810393600000 + (8259993059048206817256045414950042791 x^5)/109778087064994932293901152910861412500 - (225370748239166358154860869633396297911 x^4)/167905543173345497638468678985395200000 + (84482478374499854179900209882137400652067 x^3)/6245153397475267259386376698929004800000 - (53209374585065904235443917367730473162337 x^2)/780644174684408407423297087366125600000 + (195249095907746049143398278868958557 x)/1312624722027859173095401344105000 - 17917445582623980664271504/192983681150126956214455" x={Array.from({length: 127}, (_, i) => i)} data={{name: "多项式在每一个点上的值",mode:"markers",marker:{size:4}}} markers={[1, 27, 94, 125, 73, 66, 4, 108, 122, 119, 38, 10, 16, 51, 107, 95, 25, 40, 64, 77, 47, 126, 100, 33, 2, 54, 61, 123, 19, 5, 8, 89, 117, 111, 76, 20, 32, 102, 87, 63, 50, 80]} />

很明显，曲线一样，但是多了更多的点。

## 承诺（Commitments）
完成了我们最终多项式的构建后，我们就要进入承诺的部分了！

在Stark中，承诺（Commitments）是用于去除需要交互验证的步骤，通过将Trace的值进行默克尔树构建，从而获得虚拟的交互验证。简单来说，承诺是为了通过大量数据的Hash创造一个可信随机数。

我们将LDE拓展后的所有点的值构建成一个默克尔树，然后获得这个默克尔树的根，作为承诺值。

<Callout emoji="💡" type="info">
在Stark中的承诺是记忆的承诺。

比如，你这一步骤发送了一些承诺值A，那么你下一步发送的承诺值如果是B，那么此时如果请求随机数，返回的则是$Hash(A,B)$的结果。同时，你获得的随机数会基于这个结果生成，而你通过随机数计算出来的新结果又会成为下一个承诺值。

比如：
现在有函数$f(x)=x$ (是的，这个函数就是输入什么就输出什么 😂)，你发送了$f(1)=1$，那么此时如果请求随机数，返回的则是$Hash(1) == A$的结果。

然后你计算$f(A)=A$，那么此时如果请求随机数，返回的则是$Hash(hash(1),hash(A)) == B$的结果。

如果继续计算$f(B)=B$，则是$Hash(hash(1),hash(A),hash(B))$的结果。以此类推。

以此类推。
</Callout>

生成的图如下：

<Image src="/3_commit/merkle.png" alt="承诺" width={1000} height={1000} />